{"version":3,"sources":["webpack:////home/marco/Documents/BeCode/BeBook/node_modules/react-pure-lifecycle/es/constants.js","webpack:////home/marco/Documents/BeCode/BeBook/node_modules/react-pure-lifecycle/es/utils.js","webpack:////home/marco/Documents/BeCode/BeBook/node_modules/react-pure-lifecycle/es/components.js","webpack:////home/marco/Documents/BeCode/BeBook/node_modules/react-pure-lifecycle/es/index.js"],"names":["DEFAULT_OPTIONS","injectProps","usePureComponent","FUNCTION_NAME_REGEXP","LIFECYCLE_METHODS","UNSAFE_componentWillMount","UNSAFE_componentWillReceiveProps","UNSAFE_componentWillUpdate","componentDidCatch","componentDidMount","componentDidUpdate","componentWillMount","componentWillReceiveProps","componentWillUnmount","componentWillUpdate","getChildContext","getSnapshotBeforeUpdate","shouldComponentUpdate","utils_getComponentDisplayName","ReactComponent","displayName","name","exec","toString","isPlainObject","object","constructor","Object","utils_setLifecycleMethods","component","methods","keys","reduce","instance","methodName","method","_len","arguments","length","args","Array","_key","apply","undefined","props","concat","getLifecycleMethodWithPropsInjected","_extends","assign","target","i","source","key","prototype","hasOwnProperty","call","_classCallCheck","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","value","enumerable","writable","configurable","setPrototypeOf","__proto__","components_getClassHoc","PassedComponent","_ref","_class","_temp","_PassedComponent","PureLifecycleClass","this","_this","render","components_getFunctionHoc","passedMethods","_ref2","_class2","_temp2","ComponentToExtend","react","childContextTypes","_ComponentToExtend","PureLifecycleFunctional","_len2","_key2","_this2","react_default","a","createElement","propTypes","defaultProps","contextTypes","es_extends","es_addLifecycleMethods","optionsPassed","ComponentToTest","isReactComponent","_Object$keys$reduce","exportsObject","addMethods","fn","options","_addMethods","createSingleLifecycleMethodDecorator","__webpack_exports__"],"mappings":"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","file":"js/328df09ccbd0fad179c8.js","sourcesContent":["/**\n * @constant {Object} DEFAULT_OPTIONS\n */\nexport var DEFAULT_OPTIONS = {\n  injectProps: true,\n  usePureComponent: true\n};\n\n/**\n * @constant {RegExp} FUNCTION_NAME_REGEXP\n */\nexport var FUNCTION_NAME_REGEXP = /function ([^\\(]+)?\\(/;\n\n/**\n * @constant {boolean} IS_PRODUCTION\n * @default\n */\nexport var IS_PRODUCTION = process.env.NODE_ENV === 'production';\n\n/**\n * @constant {Object} LIFECYCLE_METHODS\n */\nexport var LIFECYCLE_METHODS = {\n  UNSAFE_componentWillMount: true,\n  UNSAFE_componentWillReceiveProps: true,\n  UNSAFE_componentWillUpdate: true,\n  componentDidCatch: true,\n  componentDidMount: true,\n  componentDidUpdate: true,\n  componentWillMount: true,\n  componentWillReceiveProps: true,\n  componentWillUnmount: true,\n  componentWillUpdate: true,\n  getChildContext: true,\n  getSnapshotBeforeUpdate: true,\n  shouldComponentUpdate: true\n};","// constants\nimport { FUNCTION_NAME_REGEXP, IS_PRODUCTION, LIFECYCLE_METHODS } from './constants';\n\n/**\n * @function createSingleLifecycleMethodDecorator\n *\n * @description\n * partial application that will return the decorator for the\n * specific method based on the function passed\n *\n * @param {function} method the method to add as a lifecycle method\n * @param {function} addMethods the method that will add the lifecycle methods to the component\n * @returns {function(ReactComponent, Object): ReactComponent} the decorator for a specific method\n */\nexport var createSingleLifecycleMethodDecorator = function createSingleLifecycleMethodDecorator(method, addMethods) {\n  return function (fn, options) {\n    var _addMethods;\n\n    if (typeof fn !== 'function') {\n      throw new TypeError('Parameter passed to ' + method + ' must be a function.');\n    }\n\n    return addMethods((_addMethods = {}, _addMethods[method] = fn, _addMethods), options);\n  };\n};\n\n/**\n * @function getComponentDisplayName\n *\n * @description\n * get the name to display for the component\n *\n * @param {ReactComponent} ReactComponent the component to get the name of\n * @returns {string} the display name of ReactComponent\n */\nexport var getComponentDisplayName = function getComponentDisplayName(ReactComponent) {\n  var componentName = ReactComponent.displayName || ReactComponent.name || (FUNCTION_NAME_REGEXP.exec(ReactComponent.toString()) || [])[1] || 'Component';\n\n  return 'PureLifecycle(' + componentName + ')';\n};\n\n/**\n * @function isPlainObject\n *\n * @description\n * is the object passed a plain object\n *\n * @param {any} object the object to test\n * @returns {boolean} is the object a plain object\n */\nexport var isPlainObject = function isPlainObject(object) {\n  return typeof object === 'object' && !!object && object.constructor === Object;\n};\n\n/**\n * @function isReactClass\n *\n * @description\n * is the component passed a react class\n *\n * @param {ReactComponent} ComponentToTest the component to test\n * @returns {boolean} is ComponentToTest a react component instantiated via the class\n */\nexport var isReactClass = function isReactClass(ComponentToTest) {\n  return !!(ComponentToTest && ComponentToTest.prototype) && typeof ComponentToTest.prototype.isReactComponent === 'object';\n};\n\n/**\n * @function getInvalidMethodWarning\n *\n * @description\n * get the warning message to display in non-production environments when the method is invalid\n *\n * @param {string} methodName the name of the invalid method\n * @returns {string} the message to display in the warning\n */\nexport var getInvalidMethodWarning = function getInvalidMethodWarning(methodName) {\n  return LIFECYCLE_METHODS[methodName] ? 'The value passed for ' + methodName + ' is not a function, skipping.' : 'The key ' + methodName + ' is not a valid lifecycle method, skipping.';\n};\n\n/**\n * @function getLifecycleMethodWithPropsInjected\n *\n * @description\n * create a higher-order function that will inject the component's props as the first argument\n *\n * @param {ReactComponent} component the component whose props to retrieve\n * @param {function} method the method to call\n * @returns {function(...Array<*>): *} the higher-order function with props injected as argument\n */\nexport var getLifecycleMethodWithPropsInjected = function getLifecycleMethodWithPropsInjected(component, method) {\n  return function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return method.apply(undefined, [component.props].concat(args));\n  };\n};\n\n/**\n * @function setLifecycleMethods\n *\n * @description\n * assign the lifecycle methods to the instance\n *\n * @param {ReactComponent} component the component whose methods will be augmented\n * @param {Object} methods the methods to apply to the component\n * @param {boolean} injectProps should the props be injected as the method's first parameter\n * @returns {ReactComponent} the augmented component\n */\nexport var setLifecycleMethods = function setLifecycleMethods(component, methods, injectProps) {\n  return Object.keys(methods).reduce(function (instance, methodName) {\n    var method = methods[methodName];\n\n    if (LIFECYCLE_METHODS[methodName] && typeof method === 'function') {\n      // eslint-disable-next-line no-param-reassign\n      instance[methodName] = injectProps ? getLifecycleMethodWithPropsInjected(component, method) : method;\n    } else if (!IS_PRODUCTION) {\n      // eslint-disable-next-line no-console\n      console.warn(getInvalidMethodWarning(methodName));\n    }\n\n    return instance;\n  }, component);\n};","var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// external dependencies\nimport React, { Component, PureComponent } from 'react';\n\n// utils\nimport { getComponentDisplayName, setLifecycleMethods } from './utils';\n\n/**\n * @function getClassHoc\n *\n * @description\n * for class-based components, use inheritance inversion to retain state, overriding the lifecycle methods\n *\n * @param {ReactComponent} PassedComponent the component to wrap in an HOC\n * @param {Object} methods the methods to apply to the HOC\n * @param {Object} options the options for customizing implementation\n * @param {boolean} options.injectProps should the props be injected into the lifecycle methods\n * @returns {ReactComponent} HOC inheriting from PassedComponent with lifecycle methods\n */\nexport var getClassHoc = function getClassHoc(PassedComponent, methods, _ref) {\n  var _class, _temp;\n\n  var injectProps = _ref.injectProps;\n\n  var displayName = getComponentDisplayName(PassedComponent);\n\n  return _temp = _class = function (_PassedComponent) {\n    _inherits(PureLifecycleClass, _PassedComponent);\n\n    function PureLifecycleClass() {\n      _classCallCheck(this, PureLifecycleClass);\n\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var _this = _possibleConstructorReturn(this, _PassedComponent.call.apply(_PassedComponent, [this].concat(args)));\n\n      setLifecycleMethods(_this, methods, injectProps);\n      return _this;\n    }\n\n    PureLifecycleClass.prototype.render = function render() {\n      return _PassedComponent.prototype.render.call(this);\n    };\n\n    return PureLifecycleClass;\n  }(PassedComponent), _class.displayName = displayName, _temp;\n};\n\n/**\n * @function getFunctionHoc\n *\n * @description\n * for function-based components, use a props proxy wrapper and add the lifecycle methods\n *\n * @param {ReactComponent} PassedComponent the component to wrap in an HOC\n * @param {Object} passedMethods the methods to apply to the HOC\n * @param {Object} options the options for customizing implementation\n * @param {boolean} options.injectProps should the props be injected into the lifecycle methods\n * @param {boolean} options.usePureComponent should the HOC be a PureComponent\n * @returns {ReactComponent} HOC wrapping PassedComponent with lifecycle methods\n */\nexport var getFunctionHoc = function getFunctionHoc(PassedComponent, passedMethods, _ref2) {\n  var _class2, _temp2;\n\n  var injectProps = _ref2.injectProps,\n      usePureComponent = _ref2.usePureComponent;\n\n  var ComponentToExtend = usePureComponent ? PureComponent : Component;\n  var displayName = getComponentDisplayName(PassedComponent);\n\n  var methods = _extends({}, passedMethods);\n  var childContextTypes = PassedComponent.childContextTypes ? _extends({}, PassedComponent.childContextTypes) : undefined;\n\n  if (childContextTypes) {\n    // eslint-disable-next-line no-param-reassign\n    delete PassedComponent.childContextTypes;\n  }\n\n  return _temp2 = _class2 = function (_ComponentToExtend) {\n    _inherits(PureLifecycleFunctional, _ComponentToExtend);\n\n    function PureLifecycleFunctional() {\n      _classCallCheck(this, PureLifecycleFunctional);\n\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      var _this2 = _possibleConstructorReturn(this, _ComponentToExtend.call.apply(_ComponentToExtend, [this].concat(args)));\n\n      setLifecycleMethods(_this2, methods, injectProps);\n      return _this2;\n    }\n\n    PureLifecycleFunctional.prototype.render = function render() {\n      return React.createElement(PassedComponent, this.props);\n    };\n\n    return PureLifecycleFunctional;\n  }(ComponentToExtend), _class2.displayName = displayName, _class2.propTypes = PassedComponent.propTypes, _class2.defaultProps = PassedComponent.defaultProps, _class2.contextTypes = PassedComponent.contextTypes, _class2.childContextTypes = childContextTypes, _temp2;\n};","var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\n// external dependencies\nimport React from 'react';\n\n//components\nimport { getClassHoc, getFunctionHoc } from './components';\n\n// constants\nimport { DEFAULT_OPTIONS, LIFECYCLE_METHODS } from './constants';\n\n// utils\nimport { createSingleLifecycleMethodDecorator, isPlainObject, isReactClass } from './utils';\n\n/**\n * @function addLifecycleMethods\n *\n * @description\n * add the lifecycle hooks to the component and return it\n *\n * @param {Object} [methods={}] the methods passed\n * @param {Object} [optionsPassed={}] the options passed\n * @returns {function(PassedComponent: ReactComponent): ReactComponent} the component augmented with lifecycle methods\n */\nvar addLifecycleMethods = function addLifecycleMethods() {\n  var methods = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var optionsPassed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!isPlainObject(methods)) {\n    throw new TypeError('Methods passed must be in the form of a plain object.');\n  }\n\n  if (!isPlainObject(optionsPassed)) {\n    throw new TypeError('Options passed must be in the form of a plain object.');\n  }\n\n  return function (PassedComponent) {\n    var getHoc = isReactClass(PassedComponent) ? getClassHoc : getFunctionHoc;\n\n    return getHoc(PassedComponent, methods, _extends({}, DEFAULT_OPTIONS, optionsPassed));\n  };\n};\n\nvar _Object$keys$reduce = Object.keys(LIFECYCLE_METHODS).reduce(function (exportsObject, method) {\n  // eslint-disable-next-line no-param-reassign\n  exportsObject[method] = createSingleLifecycleMethodDecorator(method, addLifecycleMethods);\n\n  return exportsObject;\n}, {}),\n    getChildContext = _Object$keys$reduce.getChildContext,\n    UNSAFE_componentWillMount = _Object$keys$reduce.UNSAFE_componentWillMount,\n    componentWillMount = _Object$keys$reduce.componentWillMount,\n    componentDidMount = _Object$keys$reduce.componentDidMount,\n    UNSAFE_componentWillReceiveProps = _Object$keys$reduce.UNSAFE_componentWillReceiveProps,\n    componentWillReceiveProps = _Object$keys$reduce.componentWillReceiveProps,\n    shouldComponentUpdate = _Object$keys$reduce.shouldComponentUpdate,\n    UNSAFE_componentWillUpdate = _Object$keys$reduce.UNSAFE_componentWillUpdate,\n    componentWillUpdate = _Object$keys$reduce.componentWillUpdate,\n    getSnapshotBeforeUpdate = _Object$keys$reduce.getSnapshotBeforeUpdate,\n    componentDidUpdate = _Object$keys$reduce.componentDidUpdate,\n    componentDidCatch = _Object$keys$reduce.componentDidCatch,\n    componentWillUnmount = _Object$keys$reduce.componentWillUnmount;\n\nexport { getChildContext };\nexport { UNSAFE_componentWillMount };\nexport { componentWillMount };\nexport { componentDidMount };\nexport { UNSAFE_componentWillReceiveProps };\nexport { componentWillReceiveProps };\nexport { shouldComponentUpdate };\nexport { UNSAFE_componentWillUpdate };\nexport { componentWillUpdate };\nexport { getSnapshotBeforeUpdate };\nexport { componentDidUpdate };\nexport { componentDidCatch };\nexport { componentWillUnmount };\n\nexport default addLifecycleMethods;"],"sourceRoot":""}