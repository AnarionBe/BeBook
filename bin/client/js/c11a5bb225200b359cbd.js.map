{"version":3,"sources":["webpack:////home/marco/Documents/BeCode/BeBook/node_modules/jwt-decode/lib/index.js","webpack:////home/marco/Documents/BeCode/BeBook/node_modules/jwt-decode/lib/base64_url_decode.js","webpack:////home/marco/Documents/BeCode/BeBook/node_modules/jwt-decode/lib/atob.js"],"names":["base64_url_decode","__webpack_require__","InvalidTokenError","message","this","prototype","Error","name","module","exports","token","options","pos","header","JSON","parse","split","e","atob","str","output","replace","length","decodeURIComponent","m","p","code","charCodeAt","toString","toUpperCase","b64DecodeUnicode","err","chars","InvalidCharacterError","window","bind","input","String","bs","buffer","bc","idx","charAt","fromCharCode","indexOf"],"mappings":"0FAEA,IAAAA,EAAwBC,EAAQ,IAEhC,SAAAC,EAAAC,GACAC,KAAAD,UAGAD,EAAAG,UAAA,IAAAC,MACAJ,EAAAG,UAAAE,KAAA,oBAEAC,EAAAC,QAAA,SAAAC,EAAAC,GACA,oBAAAD,EACA,UAAAR,EAAA,2BAIA,IAAAU,GAAA,KADAD,KAAA,IACAE,OAAA,IACA,IACA,OAAAC,KAAAC,MAAAf,EAAAU,EAAAM,MAAA,KAAAJ,KACG,MAAAK,GACH,UAAAf,EAAA,4BAAAe,EAAAd,WAIAK,EAAAC,QAAAP,wCCzBA,IAAAgB,EAAWjB,EAAQ,IAYnBO,EAAAC,QAAA,SAAAU,GACA,IAAAC,EAAAD,EAAAE,QAAA,UAAAA,QAAA,UACA,OAAAD,EAAAE,OAAA,GACA,OACA,MACA,OACAF,GAAA,KACA,MACA,OACAA,GAAA,IACA,MACA,QACA,iCAGA,IACA,OA1BA,SAAAD,GACA,OAAAI,mBAAAL,EAAAC,GAAAE,QAAA,gBAAAG,EAAAC,GACA,IAAAC,EAAAD,EAAAE,WAAA,GAAAC,SAAA,IAAAC,cAIA,OAHAH,EAAAJ,OAAA,IACAI,EAAA,IAAAA,GAEA,IAAAA,KAoBAI,CAAAV,GACG,MAAAW,GACH,OAAAb,EAAAE,uBCzBA,IAAAY,EAAA,oEAEA,SAAAC,EAAA9B,GACAC,KAAAD,UAGA8B,EAAA5B,UAAA,IAAAC,MACA2B,EAAA5B,UAAAE,KAAA,wBAyBAC,EAAAC,QAAA,oBAAAyB,eAAAhB,MAAAgB,OAAAhB,KAAAiB,KAAAD,SAvBA,SAAAE,GACA,IAAAjB,EAAAkB,OAAAD,GAAAf,QAAA,UACA,GAAAF,EAAAG,OAAA,KACA,UAAAW,EAAA,qEAEA,IAEA,IAAAK,EAAAC,EAAAC,EAAA,EAAAC,EAAA,EAAArB,EAAA,GAEAmB,EAAApB,EAAAuB,OAAAD,MAEAF,IAAAD,EAAAE,EAAA,KAAAF,EAAAC,IAGAC,IAAA,GAAApB,GAAAiB,OAAAM,aAAA,IAAAL,KAAA,EAAAE,EAAA,MAGAD,EAAAP,EAAAY,QAAAL,GAEA,OAAAnB","file":"js/c11a5bb225200b359cbd.js","sourcesContent":["'use strict';\n\nvar base64_url_decode = require('./base64_url_decode');\n\nfunction InvalidTokenError(message) {\n  this.message = message;\n}\n\nInvalidTokenError.prototype = new Error();\nInvalidTokenError.prototype.name = 'InvalidTokenError';\n\nmodule.exports = function (token,options) {\n  if (typeof token !== 'string') {\n    throw new InvalidTokenError('Invalid token specified');\n  }\n\n  options = options || {};\n  var pos = options.header === true ? 0 : 1;\n  try {\n    return JSON.parse(base64_url_decode(token.split('.')[pos]));\n  } catch (e) {\n    throw new InvalidTokenError('Invalid token specified: ' + e.message);\n  }\n};\n\nmodule.exports.InvalidTokenError = InvalidTokenError;\n","var atob = require('./atob');\n\nfunction b64DecodeUnicode(str) {\n  return decodeURIComponent(atob(str).replace(/(.)/g, function (m, p) {\n    var code = p.charCodeAt(0).toString(16).toUpperCase();\n    if (code.length < 2) {\n      code = '0' + code;\n    }\n    return '%' + code;\n  }));\n}\n\nmodule.exports = function(str) {\n  var output = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  switch (output.length % 4) {\n    case 0:\n      break;\n    case 2:\n      output += \"==\";\n      break;\n    case 3:\n      output += \"=\";\n      break;\n    default:\n      throw \"Illegal base64url string!\";\n  }\n\n  try{\n    return b64DecodeUnicode(output);\n  } catch (err) {\n    return atob(output);\n  }\n};\n","/**\n * The code was extracted from:\n * https://github.com/davidchambers/Base64.js\n */\n\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\nfunction InvalidCharacterError(message) {\n  this.message = message;\n}\n\nInvalidCharacterError.prototype = new Error();\nInvalidCharacterError.prototype.name = 'InvalidCharacterError';\n\nfunction polyfill (input) {\n  var str = String(input).replace(/=+$/, '');\n  if (str.length % 4 == 1) {\n    throw new InvalidCharacterError(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n  }\n  for (\n    // initialize result and counters\n    var bc = 0, bs, buffer, idx = 0, output = '';\n    // get next character\n    buffer = str.charAt(idx++);\n    // character found in table? initialize bit storage and add its ascii value;\n    ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n      // and if not first of each 4 characters,\n      // convert the first 8 bits to one ascii character\n      bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0\n  ) {\n    // try to find character in table (0-63, not found => -1)\n    buffer = chars.indexOf(buffer);\n  }\n  return output;\n}\n\n\nmodule.exports = typeof window !== 'undefined' && window.atob && window.atob.bind(window) || polyfill;\n"],"sourceRoot":""}